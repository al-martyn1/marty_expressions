/*! \file
    \brief Autogenerated enumerations description maps (Umba Enum Gen)
 */

#pragma once


#include "marty_cpp/marty_enum.h"
#include "marty_cpp/marty_flag_ops.h"
#include "marty_cpp/marty_flags.h"

#include <exception>
#include <map>
#include <set>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <unordered_set>



namespace marty{
namespace expressions{



inline std::map<BracketKind, std::string> makeBracketKindDescriptionMap()
{
std::map<BracketKind, std::string> m =
{
{ BracketKind::unknown  , "!" },
{ BracketKind::invalid  , "!" },
{ BracketKind::none     , "Returned for non-bracket symbols" },
{ BracketKind::open     , "Open bracket" },
{ BracketKind::close    , "Close bracket" }
};
return m;
} // inline std::map<BracketKind, std::string> makeBracketKindDescriptionMap()

inline const std::map<BracketKind, std::string>& getBracketKindDescriptionMap()
{
    static auto m = makeBracketKindDescriptionMap();
    return m;
}

std::string enum_get_description(BracketKind e)
{
    const auto &m = getBracketKindDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}








inline std::map<Error, std::string> makeErrorDescriptionMap()
{
std::map<Error, std::string> m =
{
{ Error::unknown                   , "!" },
{ Error::invalid                   , "!" },
{ Error::none                      , "no error - all is OK" },
{ Error::no                        , "no error - all is OK" },
{ Error::ok                        , "no error - all is OK" },
{ Error::noError                   , "no error - all is OK" },
{ Error::unknownParserState        , "parser is in an unknown state" },
{ Error::notImplemented            , "feature not implemented" },
{ Error::gotNonUnaryOrNonPrefixOp  , "got non-unary or non-prefix operator" },
{ Error::gotNonUnaryOp             , "got non-unary operator" },
{ Error::gotNonPrefixOp            , "got non-prefix operator" },
{ Error::gotOperator               , "got operator" },
{ Error::gotUnaryNonPostfixOp      , "got unary non-prefix operator" }
};
return m;
} // inline std::map<Error, std::string> makeErrorDescriptionMap()

inline const std::map<Error, std::string>& getErrorDescriptionMap()
{
    static auto m = makeErrorDescriptionMap();
    return m;
}

std::string enum_get_description(Error e)
{
    const auto &m = getErrorDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}








inline std::map<ParserState, std::string> makeParserStateDescriptionMap()
{
std::map<ParserState, std::string> m =
{
{ ParserState::unknown                     , "!Unknown parser state" },
{ ParserState::invalid                     , "!Unknown parser state" },
{ ParserState::waitUnaryPrefixOpOrValue    , "unary prefix operator, variable, function or literal" },
{ ParserState::initial                     , "unary prefix operator, variable, function or literal" },
{ ParserState::waitOperator                , "unary postfix operator, binary, ternary or n-Ary operator" },
{ ParserState::waitOperatorOrFunctionCall  , "binary, ternary or n-Ary operator or function call" },
{ ParserState::waitOperand                 , "operand (literal or variable)" }
};
return m;
} // inline std::map<ParserState, std::string> makeParserStateDescriptionMap()

inline const std::map<ParserState, std::string>& getParserStateDescriptionMap()
{
    static auto m = makeParserStateDescriptionMap();
    return m;
}

std::string enum_get_description(ParserState e)
{
    const auto &m = getParserStateDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}








inline std::map<ItemType, std::string> makeItemTypeDescriptionMap()
{
std::map<ItemType, std::string> m =
{
{ ItemType::unknown               , "!" },
{ ItemType::invalid               , "!" },
{ ItemType::void_                 , "" },
{ ItemType::operator_             , "" },
{ ItemType::boolLiteral           , "" },
{ ItemType::integerLiteral        , "" },
{ ItemType::floatingPointLiteral  , "" },
{ ItemType::stringLiteral         , "" },
{ ItemType::symbolLiteral         , "" },
{ ItemType::identifier            , "" },
{ ItemType::expressionEntry       , "" },
{ ItemType::functionCall          , "" },
{ ItemType::functionalCast        , "" },
{ ItemType::cast                  , "" }
};
return m;
} // inline std::map<ItemType, std::string> makeItemTypeDescriptionMap()

inline const std::map<ItemType, std::string>& getItemTypeDescriptionMap()
{
    static auto m = makeItemTypeDescriptionMap();
    return m;
}

std::string enum_get_description(ItemType e)
{
    const auto &m = getItemTypeDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}








inline std::map<TokenContext, std::string> makeTokenContextDescriptionMap()
{
std::map<TokenContext, std::string> m =
{
{ TokenContext::unknown       , "!" },
{ TokenContext::invalid       , "!" },
{ TokenContext::normal        , "Parser is in normal state" },
{ TokenContext::functionCall  , "Parser is currently parsing function call arguments list" }
};
return m;
} // inline std::map<TokenContext, std::string> makeTokenContextDescriptionMap()

inline const std::map<TokenContext, std::string>& getTokenContextDescriptionMap()
{
    static auto m = makeTokenContextDescriptionMap();
    return m;
}

std::string enum_get_description(TokenContext e)
{
    const auto &m = getTokenContextDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}








inline std::map<OperatorFeatures, std::string> makeOperatorFeaturesDescriptionMap()
{
std::map<OperatorFeatures, std::string> m =
{
{ OperatorFeatures::unknown                , "!" },
{ OperatorFeatures::invalid                , "!" },
{ OperatorFeatures::none                   , "!" },
{ OperatorFeatures::regular                , "" },
{ OperatorFeatures::scope                  , "Scope resolution operator" },
{ OperatorFeatures::groupping              , "Operations groupping for priority raising" },
{ OperatorFeatures::simpleCast             , "Simple (C-like) cast" },
{ OperatorFeatures::functionalCast         , "Functional cast" },
{ OperatorFeatures::functionCall           , "Function call" },
{ OperatorFeatures::indexation             , "Indexation" },
{ OperatorFeatures::templateInstantiation  , "Template instantiation" }
};
return m;
} // inline std::map<OperatorFeatures, std::string> makeOperatorFeaturesDescriptionMap()

inline const std::map<OperatorFeatures, std::string>& getOperatorFeaturesDescriptionMap()
{
    static auto m = makeOperatorFeaturesDescriptionMap();
    return m;
}

std::string enum_get_description(OperatorFeatures e)
{
    const auto &m = getOperatorFeaturesDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}










inline std::map<OperatorRestrictions, std::string> makeOperatorRestrictionsDescriptionMap()
{
std::map<OperatorRestrictions, std::string> m =
{
{ OperatorRestrictions::unknown                   , "!" },
{ OperatorRestrictions::invalid                   , "!" },
{ OperatorRestrictions::none                      , "!" },
{ OperatorRestrictions::requiresNameRight         , "Requires name (identifier) at right" },
{ OperatorRestrictions::requiresNameLeft          , "Requires name (identifier) at left" },
{ OperatorRestrictions::requiresScopeRight        , "Requires scope operator at right" },
{ OperatorRestrictions::requiresScopeLeft         , "Requires scope operator at left" },
{ OperatorRestrictions::requiresScopeOrNameRight  , "Requires scope operator or name (identifier) at right" },
{ OperatorRestrictions::requiresScopeOrNameLeft   , "Requires scope operator or name (identifier) at left" }
};
return m;
} // inline std::map<OperatorRestrictions, std::string> makeOperatorRestrictionsDescriptionMap()

inline const std::map<OperatorRestrictions, std::string>& getOperatorRestrictionsDescriptionMap()
{
    static auto m = makeOperatorRestrictionsDescriptionMap();
    return m;
}

std::string enum_get_description(OperatorRestrictions e)
{
    const auto &m = getOperatorRestrictionsDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}










inline std::map<OperatorAffixation, std::string> makeOperatorAffixationDescriptionMap()
{
std::map<OperatorAffixation, std::string> m =
{
{ OperatorAffixation::unknown  , "!" },
{ OperatorAffixation::invalid  , "!" },
{ OperatorAffixation::none     , "!" },
{ OperatorAffixation::prefix   , "Prefix mode allowed for operator" },
{ OperatorAffixation::postfix  , "Postfix mode allowed for operator" }
};
return m;
} // inline std::map<OperatorAffixation, std::string> makeOperatorAffixationDescriptionMap()

inline const std::map<OperatorAffixation, std::string>& getOperatorAffixationDescriptionMap()
{
    static auto m = makeOperatorAffixationDescriptionMap();
    return m;
}

std::string enum_get_description(OperatorAffixation e)
{
    const auto &m = getOperatorAffixationDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}










inline std::map<OperatorAssociativity, std::string> makeOperatorAssociativityDescriptionMap()
{
std::map<OperatorAssociativity, std::string> m =
{
{ OperatorAssociativity::unknown      , "!" },
{ OperatorAssociativity::invalid      , "!" },
{ OperatorAssociativity::none         , "!" },
{ OperatorAssociativity::leftToRight  , "left-hand operator  (Left-to-right →) левая ассоциативность, при которой вычисление выражения происходит слева направо" },
{ OperatorAssociativity::leftHand     , "left-hand operator  (Left-to-right →) левая ассоциативность, при которой вычисление выражения происходит слева направо" },
{ OperatorAssociativity::left         , "left-hand operator  (Left-to-right →) левая ассоциативность, при которой вычисление выражения происходит слева направо" },
{ OperatorAssociativity::rightToLeft  , "right-hand operator (Right-to-left ←) правая ассоциативность — справа налево" },
{ OperatorAssociativity::rightHand    , "right-hand operator (Right-to-left ←) правая ассоциативность — справа налево" },
{ OperatorAssociativity::right        , "right-hand operator (Right-to-left ←) правая ассоциативность — справа налево" }
};
return m;
} // inline std::map<OperatorAssociativity, std::string> makeOperatorAssociativityDescriptionMap()

inline const std::map<OperatorAssociativity, std::string>& getOperatorAssociativityDescriptionMap()
{
    static auto m = makeOperatorAssociativityDescriptionMap();
    return m;
}

std::string enum_get_description(OperatorAssociativity e)
{
    const auto &m = getOperatorAssociativityDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}










inline std::map<OperatorArity, std::string> makeOperatorArityDescriptionMap()
{
std::map<OperatorArity, std::string> m =
{
{ OperatorArity::unknown         , "!" },
{ OperatorArity::invalid         , "!" },
{ OperatorArity::none            , "Zero number of operands" },
{ OperatorArity::nonary          , "Zero number of operands" },
{ OperatorArity::unary           , "Unary operator. Mutually exclusive with `ternary` and `nAry` flags. Can be combined with `binary`." },
{ OperatorArity::binary          , "Binary operator. Mutually exclusive with `ternary` and `nAry` flags. Can be combined with `unary`." },
{ OperatorArity::ternary         , "Ternary operator. Mutually exclusive with other arity flags." },
{ OperatorArity::nAry            , "N-arity. Mutually exclusive with other arity flags." },
{ OperatorArity::unaryBinary     , "Unary or binary operator" },
{ OperatorArity::fixedArityMask  , "Mask to pick out fixed size arity" },
{ OperatorArity::arityMask       , "Mask to pick out arity" }
};
return m;
} // inline std::map<OperatorArity, std::string> makeOperatorArityDescriptionMap()

inline const std::map<OperatorArity, std::string>& getOperatorArityDescriptionMap()
{
    static auto m = makeOperatorArityDescriptionMap();
    return m;
}

std::string enum_get_description(OperatorArity e)
{
    const auto &m = getOperatorArityDescriptionMap();
    auto it = m.find(e);
    return it==m.end() ? std::string("No description") : it->second;
}







} // namespace expressions
} // namespace marty

