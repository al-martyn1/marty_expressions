#Преобразование произвольной логической формулы в конъюнктивную (КНФ) и дизъюнктивную (ДНФ) нормальную форму. Пошаговая инструкция


## Общая концепция

И **КНФ**, и **ДНФ** являются нормированными представлениями логических формул. Они строятся из:
*   **Литералов**: переменных (например, `A`) или их отрицаний (¬`A`).
*   **Элементарных дизъюнкций** (дизъюнктов): выражений вида `A ∨ B ∨ ¬C`. Конъюнкция таких дизъюнктов — это **КНФ**.
    *   Пример КНФ: `(A ∨ ¬B) ∧ (B ∨ C)`
*   **Элементарных конъюнкций** (конъюнктов): выражений вида `A ∧ B ∧ ¬C`. Дизъюнкция таких конъюнкций — это **ДНФ**.
    *   Пример ДНФ: `(A ∧ B) ∨ (B ∧ ¬C)`

Цель преобразования — избавиться от всех логических операций, кроме `∧`, `∨` и `¬`, и привести формулу к нужной структуре.

---

## Универсальный алгоритм преобразования (шаги 1-4 общие)

Независимо от того, какую форму вы хотите получить (КНФ или ДНФ), первые четыре шага одинаковы.

**Шаг 1: Устранить импликацию и эквивалентность**
Замените все вхождения операций `→` и `↔` на их эквивалентные выражения, использующие только `∧`, `∨`, `¬`.
*   `A → B` эквивалентно `¬A ∨ B`
*   `A ↔ B` эквивалентно `(A ∧ B) ∨ (¬A ∧ ¬B)` или `(¬A ∨ B) ∧ (A ∨ ¬B)`

**Шаг 2: Продвинуть отрицания (Привести к нормальной форме отрицания)**
Используйте **законы де Моргана**, чтобы "продвинуть" отрицания (`¬`) к самим переменным. Это значит, что знак отрицания должен стоять только перед переменной, а не перед целой скобкой.
*   ¬(A ∧ B) эквивалентно ¬A ∨ ¬B
*   ¬(A ∨ B) эквивалентно ¬A ∧ ¬B
*   Также используйте закон двойного отрицания: ¬¬A эквивалентно A

**Пример:** Преобразуем ¬(A ∨ ¬B)
1.  Применяем де Моргана: ¬A ∧ ¬(¬B)
2.  Применяем двойное отрицание: ¬A ∧ B
Теперь все отрицания стоят только перед переменными.

**Шаг 3: Применить законы дистрибутивности (здесь пути к ДНФ и КНФ расходятся)**
Это ключевой шаг, который определяет, получится у вас КНФ или ДНФ.

---

## Алгоритм для получения Дизъюнктивной Нормальной Формы (ДНФ)

**Цель:** Представить формулу в виде дизъюнкции конъюнктов.

На **Шаге 3** для ДНФ нужно применять **дистрибутивность конъюнкции относительно дизъюнкции**:
`A ∧ (B ∨ C)` эквивалентно `(A ∧ B) ∨ (A ∧ C)`

**Общая тактика:** Раскрывать скобки, чтобы конъюнкция оказалась "внутри", а дизъюнкция — "снаружи".

**Шаг 4 (для ДНФ): Упрощение (опционально, но рекомендуется)**
*   Удалить повторяющиеся литералы в конъюнктах: `(A ∧ A ∧ B)` -> `(A ∧ B)`
*   Удалить конъюнкты, которые заведомо ложны (содержат `A` и `¬A`).
*   Использовать законы поглощения.

---

## Алгоритм для получения Конъюнктивной Нормальной Формы (КНФ)

**Цель:** Представить формулу в виде конъюнкции дизъюнктов.

На **Шаге 3** для КНФ нужно применять **дистрибутивность дизъюнкции относительно конъюнкции**:
`A ∨ (B ∧ C)` эквивалентно `(A ∨ B) ∧ (A ∨ C)`

**Общая тактика:** Раскрывать скобки, чтобы дизъюнкция оказалась "внутри", а конъюнкция — "снаружи".

**Шаг 4 (для КНФ): Упрощение (опционально, но рекомендуется)**
*   Удалить повторяющиеся литералы в дизъюнктах: `(A ∨ A ∨ B)` -> `(A ∨ B)`
*   Удалить дизъюнкты, которые заведомо истинны (содержат `A` и `¬A`).
*   Использовать законы поглощения.

---

## Пример преобразования

Возьмем формулу: `(A → B) ∧ (B → C)`

**Шаг 1: Устраняем импликации**
`(¬A ∨ B) ∧ (¬B ∨ C)`

**Получаем КНФ:**
Форма `(¬A ∨ B) ∧ (¬B ∨ C)` уже является **КНФ**! Это конъюнкция двух дизъюнктов. Дальнейшие действия не требуются.

**Получаем ДНФ:**
Нам нужно превратить эту конъюнкцию в дизъюнкцию.

**Шаг 3 (для ДНФ):** Применяем дистрибутивность `∧` относительно `∨`. Наша формула имеет вид `X ∧ Y`, где `X = (¬A ∨ B)`, а `Y = (¬B ∨ C)`.

`(¬A ∨ B) ∧ (¬B ∨ C)` раскрывается как:
`[¬A ∧ (¬B ∨ C)] ∨ [B ∧ (¬B ∨ C)]` (дистрибутивность)

Теперь раскроем скобки внутри каждой части:
1.  `¬A ∧ (¬B ∨ C)` = `(¬A ∧ ¬B) ∨ (¬A ∧ C)` (дистрибутивность)
2.  `B ∧ (¬B ∨ C)` = `(B ∧ ¬B) ∨ (B ∧ C)` (дистрибутивность)

Подставляем обратно:
`[(¬A ∧ ¬B) ∨ (¬A ∧ C)] ∨ [(B ∧ ¬B) ∨ (B ∧ C)]`

**Шаг 4 (для ДНФ): Упрощаем**
*   `(B ∧ ¬B)` — это всегда ложь. Его можно удалить, так как в дизъюнкции `Ложь ∨ X` эквивалентно `X`.
*   Убираем лишние скобки (ассоциативность ∨).

**Итоговая ДНФ:**
`(¬A ∧ ¬B) ∨ (¬A ∧ C) ∨ (B ∧ C)`

Это дизъюнкция трех конъюнктов.

---

## Важное дополнение: Совершенная форма (СДНФ и СКНФ)

Часто требуются не просто КНФ/ДНФ, а **совершенные** нормальные формы (**СДНФ** и **СКНФ**). Их отличие в том, что в каждой элементарной конъюнкции (для СДНФ) или дизъюнкции (для СКНФ) должны присутствовать **все переменные** из используемого набора.

**Как получить совершенную форму?**
1.  Постройте таблицу истинности для формулы.
2.  **Для СДНФ:**
    *   Выберите все строки, где формула принимает значение **Истина (1)**.
    *   Для каждой такой строки составьте конъюнкцию всех переменных: если значение переменной в строке равно 1, берите ее саму, если 0 — берите ее отрицание.
    *   Объедините все полученные конъюнкции знаком дизъюнкции (`∨`).
3.  **Для СКНФ:**
    *   Выберите все строки, где формула принимает значение **Ложь (0)**.
    *   Для каждой такой строки составьте дизъюнкцию всех переменных: если значение переменной в строке равно 0, берите ее саму, если 1 — берите ее отрицание.
    *   Объедините все полученные дизъюнкции знаком конъюнкции (`∧`).

Этот метод надежен и прост для понимания, хотя и может быть громоздким для формул с большим количеством переменных.

## Итог

| Действие | Для ДНФ | Для КНФ |
| :--- | :--- | :--- |
| **1. Устранить →, ↔** | `A → B` становится `¬A ∨ B` | `A → B` становится `¬A ∨ B` |
| **2. Продвинуть ¬** | Использовать де Моргана: ¬(A ∧ B) -> ¬A ∨ ¬B | Использовать де Моргана: ¬(A ∨ B) -> ¬A ∧ ¬B |
| **3. Дистрибутивность** | **∧ над ∨**: `A ∧ (B ∨ C)` -> `(A ∧ B) ∨ (A ∧ C)` | **∨ над ∧**: `A ∨ (B ∧ C)` -> `(A ∨ B) ∧ (A ∨ C)` |
| **4. Упрощение** | Удалить противоречивые конъюнкты | Удалить тождественно истинные дизъюнкты |



## Закон поглощения

### Суть закона поглощения

Закон поглощения гласит, что если у нас есть логическое выражение, состоящее из операции И (конъюнкции, `∧`) или ИЛИ (дизъюнкции, `∨`) над переменными, где одна часть выражения является подмножеством другой, то всё выражение может быть "поглощено" (упрощено до) этой большей части.

Закон имеет две основные формы:

#### 1. Закон поглощения для конъюнкции (И)

**Формула:**
`A ∧ (A ∨ B) ≡ A`

**Словесная формулировка:**
Логическое И между выражением `A` и результатом логического ИЛИ между `A` и любым другим выражением `B` эквивалентно просто `A`. Выражение `(A ∨ B)` "поглощается" выражением `A`.

**Пример:**
"Сегодня идет дождь И (Сегодня идет дождь ИЛИ завтра будет солнце)"
Упрощается до: "Сегодня идет дождь".

Если сегодня идет дождь (`A` истинно), то вся скобка `(A ∨ B)` автоматически истинна (по определению ИЛИ). Таким образом, итоговое выражение `A ∧ (истина)` зависит только от `A`.
Если же сегодня дождя нет (`A` ложно), то и всё выражение ложно, независимо от `B`.

#### 2. Закон поглощения для дизъюнкции (ИЛИ)

**Формула:**
`A ∨ (A ∧ B) ≡ A`

**Словесная формулировка:**
Логическое ИЛИ между выражением `A` и результатом логического И между `A` и любым другим выражением `B` эквивалентно просто `A`. Выражение `(A ∧ B)` "поглощается" выражением `A`.

**Пример:**
"Я куплю яблоки ИЛИ (Я куплю яблоки И апельсины)"
Упрощается до: "Я куплю яблоки".

Если я покупаю яблоки (`A` истинно), то всё исходное выражение истинно (по определению ИЛИ).
Если я не покупаю яблоки (`A` ложно), то и выражение `(A ∧ B)` ложно (так как `ложь ∧ B = ложь`). Таким образом, итогом будет `ложь ИЛИ ложь = ложь`, что again зависит только от `A`.

### Наглядная проверка с помощью таблиц истинности

Мы можем доказать эквивалентность, построив таблицы истинности для обеих частей уравнений.

**Проверка закона `A ∧ (A ∨ B) ≡ A`:**

| A | B | A ∨ B | A ∧ (A ∨ B) |
|---|---|-------|-------------|
| 0 | 0 |   0   |      0      |
| 0 | 1 |   1   |      0      |
| 1 | 0 |   1   |      1      |
| 1 | 1 |   1   |      1      |

Сравниваем последний столбец (`A ∧ (A ∨ B)`) и первый столбец (`A`). Они **идентичны**. Что и требовалось доказать.

**Проверка закона `A ∨ (A ∧ B) ≡ A`:**

| A | B | A ∧ B | A ∨ (A ∧ B) |
|---|---|-------|-------------|
| 0 | 0 |   0   |      0      |
| 0 | 1 |   0   |      0      |
| 1 | 0 |   0   |      1      |
| 1 | 1 |   1   |      1      |

Последний столбец (`A ∨ (A ∧ B)`) снова **идентичен** первому столбцу (`A`).

### Аналогия с теорией множеств

Закон поглощения также работает в теории множеств, что помогает лучше понять его суть.

*   **Для объединения (аналог ИЛИ):** `A ∪ (A ∩ B) = A`
    Объединение множества `A` с его частью (пересечением с `B`) даст просто множество `A`.
    ![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/A_absorbs_A_cap_B.svg/180px-A_absorbs_A_cap_B.svg.png)

*   **Для пересечения (аналог И):** `A ∩ (A ∪ B) = A`
    Пересечение множества `A` с бóльшим множеством (которое включает `A` и `B`) даст просто множество `A`.
    ![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/A_absorbs_A_cup_B.svg/180px-A_absorbs_A_cup_B.svg.png)

### Зачем это нужно?

Главное применение закона поглощения — **упрощение логических выражений**. Сложные формулы, используемые в алгоритмах, цифровой схемотехнике, проектировании баз данных и написании условий в программировании, часто можно сделать намного короче и понятнее, применяя этот и другие законы логики (де Моргана, дистрибутивный и т.д.). Это повышает эффективность и снижает вероятность ошибок.

**Итог:** Закон поглощения — это мощный инструмент для преобразования и упрощения логических выражений, который показывает, что добавление избыточной информации (через `∧` или `∨`) не меняет исходного значения выражения.


> У меня есть логическое выражение.
> Использованы для упрощения все законы логики - де Моргана, схлопывание двойного отрицания, "спуск" отрицаний, законы поглощения и тп.
> Но сложное выражение всё равно выглядит, как многоуровневое дерево.
> Я же хочу, чтобы выражение было деревом константной глубины - то есть, либо в форме ДНФ, либо в форме КНФ.
> Что мне надо сделать для этого?

Отличный вопрос! Вы столкнулись с классической ситуацией. Упрощение выражений с помощью законов де Моргана, поглощения и т.д. — это *эквивалентное преобразование*. Оно сохраняет структуру дерева и делает его "изящнее", но не меняет его фундаментальную многоуровневую природу.

Чтобы получить форму постоянной глубины (ДНФ или КНФ), нужен не просто процесс *упрощения*, а процесс *нормализации* (приведения к нормальной форме). Это алгоритмическая процедура.

Вот что вам нужно сделать, шаг за шагом:

### 1. Определитесь с целевой формой

*   **ДНФ (Дизъюнктивная нормальная форма)**:
    Это ИЛИ одного или нескольких И.
    Структура: `(И) ИЛИ (И) ИЛИ (И) ...`
    Пример: `(A ∧ ¬B ∧ C) ∨ (¬A ∧ D) ∨ (B)`

*   **КНФ (Конъюнктивная нормальная форма)**:
    Это И одного или нескольких ИЛИ.
    Структура: `(ИЛИ) И (ИЛИ) И (ИЛИ) ...`
    Пример: `(A ∨ ¬B ∨ C) ∧ (¬A ∨ D) ∧ (B ∨ C)`

Выбор между ДНФ и КНФ часто зависит от дальнейшего применения. Например, КНФ невероятно важна для задачи выполнимости (SAT).

---

### 2. Выберите метод приведения

Есть два основных алгоритмических пути.

#### Метод 1: Через таблицу истинности (Наиболее straightforward для небольшого числа переменных)

Этот метод гарантированно даст вам **совершенную ДНФ (СДНФ)** или **совершенную КНФ (СКНФ)**.

**Для получения СДНФ:**
1.  Постройте таблицу истинности для вашего выражения.
2.  Выберите **все строки, где выражение равно `1` (истина)**.
3.  Для каждой такой строки составьте конъюнкцию (И) всех переменных.
    *   Если переменная в этой строке равна `1`, берите её саму.
    *   Если переменная равна `0`, берите её отрицание.
4.  Соедините все полученные конъюнкции знаком дизъюнкции (ИЛИ).

**Пример:** Для выражения, которое истинно при `(A=0, B=1)` и `(A=1, B=0)`.
*   Для первого набора: `¬A ∧ B`
*   Для второго набора: `A ∧ ¬B`
*   **СДНФ:** `(¬A ∧ B) ∨ (A ∧ ¬B)` (Это известное "исключающее ИЛИ").

**Для получения СКНФ:**
1.  Постройте таблицу истинности.
2.  Выберите **все строки, где выражение равно `0` (ложь)**.
3.  Для каждой такой строки составьте дизъюнкцию (ИЛИ) всех переменных.
    *   Если переменная в этой строке равна `0`, берите её саму.
    *   Если переменная равна `1`, берите её отрицание.
4.  Соедините все полученные дизъюнкции знаком конъюнкции (И).

**Преимущества метода:**
*   Прост для понимания.
*   Всегда работает.

**Недостатки:**
*   Экспоненциальная сложность. Для `n` переменных нужно `2^n` строк. Уже при 6-8 переменных становится очень трудоёмко.

#### Метод 2: Алгебраическое преобразование (с помощью эквивалентностей)

Это более продвинутый способ, который не требует построения полной таблицы истинности.

**Алгоритм приведения к ДНФ:**
1.  **Избавьтесь от импликаций и эквивалентностей:**
    *   `A → B` заменяйте на `¬A ∨ B`
    *   `A ↔ B` заменяйте на `(A ∧ B) ∨ (¬A ∧ ¬B)`
2.  **"Загоните" отрицания к переменным** с помощью законов де Моргана и снятия двойного отрицания. У вас должны остаться отрицания только у переменных, а не у сложных выражений.
    *   `¬(A ∨ B)` становится `¬A ∧ ¬B`
    *   `¬(A ∧ B)` становится `¬A ∨ ¬B`
    *   `¬¬A` становится `A`
3.  **Воспользуйтесь дистрибутивностью** закона `∧` относительно `∨`, чтобы "перемножить" скобки, как в алгебре.
    *   `A ∧ (B ∨ C)` становится `(A ∧ B) ∨ (A ∧ C)`
    *   `(A ∨ B) ∧ (C ∨ D)` становится `(A ∧ C) ∨ (A ∧ D) ∨ (B ∧ C) ∨ (B ∧ D)`

**Алгоритм приведения к КНФ:**
Первые два шага *абсолютно такие же*.
1.  Убрать импликации и эквивалентности.
2.  Загнать отрицания к переменным.
3.  **Воспользуйтесь дистрибутивностью** закона `∨` относительно `∧`.
    *   `A ∨ (B ∧ C)` становится `(A ∨ B) ∧ (A ∨ C)`
    *   `(A ∧ B) ∨ (C ∧ D)` становится `(A ∨ C) ∧ (A ∨ D) ∧ (B ∨ C) ∧ (B ∨ D)`

---

### 3. (Опционально) Упростите полученную ДНФ/КНФ

После приведения у вас может получиться избыточная форма. Вы снова можете применить законы поглощения, склеивания и т.д., чтобы её минимизировать.
*   **Склеивание:** `(A ∧ B) ∨ (A ∧ ¬B) = A`
*   **Поглощение:** `A ∨ (A ∧ B) = A`

### Краткий итог-инструкция:

1.  **Цель:** ДНФ или КНФ?
2.  **Если переменных мало (<6):** Используйте **таблицу истинности**. Это самый безотказный способ.
3.  **Если переменных много:**
    *   Уберите `→` и `↔`.
    *   Используйте де Моргана, чтобы отрицания стояли только у переменных.
    *   **Для ДНФ:** Раскрывайте скобки, используя дистрибутивность `∧` относительно `∨` (`A ∧ (B ∨ C) = (A ∧ B) ∨ (A ∧ C)`).
    *   **Для КНФ:** Раскрывайте скобки, используя дистрибутивность `∨` относительно `∧` (`A ∨ (B ∧ C) = (A ∨ B) ∧ (A ∨ C)`).
4.  **(По желанию)** Упростите результат, убирая повторяющиеся и поглощаемые члены.

Это формальный процесс, который гарантированно превратит любое сложное логическое дерево в плоскую структуру константной глубины.


> У меня есть логическое выражение.
> Использованы для упрощения все законы логики - де Моргана, схлопывание двойного отрицания, "спуск" отрицаний, законы поглощения и тп.
> Но сложное выражение всё равно выглядит, как многоуровневое дерево.
> Я же хочу, чтобы выражение было деревом константной глубины - то есть, либо в форме ДНФ, либо в форме КНФ.
> У меня нет операций импликаций и эквивалентностей, только операции И и ИЛИ, и группирующие скобки.
> Что мне надо сделать для этого?

Отличный вопрос! Вы столкнулись с классической задачей — приведением логического выражения к нормальной форме. Поскольку вы уже упростили выражение с помощью законов алгебры логики, осталось применить финальный, алгоритмический шаг.

Чтобы получить **ДНФ (Дизъюнктивную Нормальную Форму)** или **КНФ (Конъюнктивную Нормальную Форму)**, вам нужно использовать **законы дистрибутивности** (распределительные законы).

Глубина дерева в этих формах действительно постоянна:
*   **ДНФ**: `ИЛИ` от любого количества термов, каждый из которых — `И` от любого количества литералов (переменных или их отрицаний).
    *   `(И) ИЛИ (И) ИЛИ (И) ИЛИ ...`
*   **КНФ**: `И` от любого количества термов, каждый из которых — `ИЛИ` от любого количества литералов.
    *   `(ИЛИ) И (ИЛИ) И (ИЛИ) И ...`

### Что нужно делать? Алгоритм преобразования

Выбор между ДНФ и КНФ зависит от вашей конечной цели. Процесс для них симметричен.

#### 1. Если вам нужна **ДНФ** (сумма произведений):

Ваша цель — "загнать" все операции `ИЛИ` под операции `И`. Для этого используется **дистрибутивность `И` относительно `ИЛИ`**:
`A & (B ∨ C) ≡ (A & B) ∨ (A & C)`

**Шаги:**
1.  **Убедитесь, что отрицания стоят только над переменными.** Если у вас есть отрицание над скобкой, используйте законы де Моргана, чтобы "протолкнуть" его внутрь, пока отрицания не окажутся непосредственно у переменных.
    *   Например: `¬(A ∨ B)` превращается в `¬A & ¬B`; `¬(A & B)` превращается в `¬A ∨ ¬B`.

2.  **Применяйте закон дистрибутивности (`И` над `ИЛИ`) до тех пор, пока операция `И` не окажется внутри всех скобок с операцией `ИЛИ`.** Вы как бы "умножаете" скобки на скобки, как в обычной алгебре.
    *   Пример преобразования к ДНФ:
        *   Исходное выражение: `(A ∨ B) & (C ∨ D)`
        *   Применяем дистрибутивность: рассматриваем первую скобку `(A ∨ B)` как один множитель.
        *   `(A ∨ B) & C ∨ (A ∨ B) & D` (здесь еще не ДНФ, т.к. `И` снаружи)
        *   Применяем дистрибутивность еще раз для обеих частей:
        *   `(A & C) ∨ (B & C) ∨ (A & D) ∨ (B & D)`
        *   **Готово!** Это идеальная ДНФ: глубина дерева постоянна (всего два уровня: на нижнем уровне `И`, на верхнем `ИЛИ`).

#### 2. Если вам нужна **КНФ** (произведение сумм):

Ваша цель — "загнать" все операции `И` под операции `ИЛИ`. Для этого используется **дистрибутивность `ИЛИ` относительно `И`**:
`A ∨ (B & C) ≡ (A ∨ B) & (A ∨ C)`

**Шаги:**
1.  **Аналогично первому шагу для ДНФ:** убедитесь, что отрицания стоят только над переменными (используйте де Моргана).

2.  **Применяйте закон дистрибутивности (`ИЛИ` над `И`) до тех пор, пока операция `ИЛИ` не окажется внутри всех скобок с операцией `И`.**
    *   Пример преобразования к КНФ:
        *   Исходное выражение: `(A & B) ∨ (C & D)`
        *   Применяем дистрибутивность: рассматриваем первую скобку `(A & B)` как одно слагаемое.
        *   `(A & B) ∨ C) & ((A & B) ∨ D)` (здесь еще не КНФ)
        *   Применяем дистрибутивность еще раз для обеих скобок:
        *   `(A ∨ C) & (B ∨ C) & (A ∨ D) & (B ∨ D)`
        *   **Готово!** Это идеальная КНФ: глубина дерева постоянна (всего два уровня: на нижнем уровне `ИЛИ`, на верхнем `И`).

---

### Краткая инструкция-шпаргалка:

1.  **Избавьтесь от всех сложных отрицаний** с помощью законов де Моргана и снятия двойного отрицания. Ваша задача — чтобы `НЕ` (`¬`) встречались только у одиночных переменных (`¬A`, а не `¬(A&B)`).
2.  **Определитесь, что вам нужно: ДНФ или КНФ.**
3.  **Для ДНФ:**
    *   Смотрите на выражение. Если на верхнем уровне `И` (например, `(...) & (...)`), а внутри скобок есть `ИЛИ`, применяйте правило: `(X ∨ Y) & Z -> (X & Z) ∨ (Y & Z)`.
    *   Продолжайте "раскрывать скобки", как умножение многочленов, пока везде на верхнем уровне не останется только `ИЛИ`, а внутри каждой скобки — только `И`.
4.  **Для КНФ:**
    *   Смотрите на выражение. Если на верхнем уровне `ИЛИ` (например, `(...) ∨ (...)`), а внутри скобок есть `И`, применяйте правило: `(X & Y) ∨ Z -> (X ∨ Z) & (Y ∨ Z)`.
    *   Продолжайте "выносить за скобки", пока везде на верхнем уровне не останется только `И`, а внутри каждой скобки — только `ИЛИ`.

### Важное замечание:

В процессе такого раскрытия **выражение может очень сильно разрастись**. Если у вас было `n` переменных под скобками, раскрытие может привести к экспоненциальному росту количества термов (до `2^n`). Это плата за получение плоской, двухуровневой структуры. Компьютеры справляются с этим лучше людей, но для сложных выражений с десятками переменных это может быть вычислительно сложной задачей.

**Пример для закрепления:**

Преобразуем выражение `¬(A & (B ∨ ¬C))` к ДНФ.

1.  Избавляемся от сложного отрицания (де Морган):
    *   `¬(A & (B ∨ ¬C)) ≡ ¬A ∨ ¬(B ∨ ¬C)`
2.  Продолжаем применять де Моргана для оставшегося сложного отрицания:
    *   `¬A ∨ (¬B & ¬¬C)`
3.  Схлопываем двойное отрицание:
    *   `¬A ∨ (¬B & C)`
4.  *Теперь у нас уже почти ДНФ, но нужно полностью раскрыть.* Вид: `[¬A] ∨ [¬B & C]`. Применяем дистрибутивность `И` над `ИЛИ` (хотя она уже почти применена). Можно представить `¬A` как `(¬A & True)`, но проще увидеть, что это выражение уже является ДНФ, состоящей из двух термов: первого терма `(¬A)` и второго терма `(¬B & C)`.

Итоговая ДНФ: `¬A ∨ (¬B & C)`
