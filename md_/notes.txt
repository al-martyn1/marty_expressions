PositionInfoType - параметр некоторых шаблонов, должен быть интегрального типа, каким-то образом
указывает на положение ткена во входном потоке.

Что у нас может быть в качестве входного токена?

- Целое число - BigInt/int64_t - знаковое, 
  но в токенизере храняться беззнаковый тип, если в токенизере тоже BigInt, то нет проблем,
  иначе надо кастить. Имя структуры целочисленного литерала - IntegerLiteral.

- Число с плавающей точкой - используем marty::Decimal или double. Имя структуры литерала - FloatingPointLiteral.

- Строковый литерал - храним в виде строки. Имя структуры литерала - StringLiteral.

- Символьный литерал - храним в виде строки. Имя структуры литерала - SymbolLiteral.

- Идентификатор - имя или список имён - список имён получается из последовательности идентификаторов,
  разделённых namespace-разделителем. Имя структуры литерала - IdentifierLiteral.

- Скобка. Скобка - тоже оператор. Открывающая, закрывающая - разные оператор-токены.
  Надо уметь по типу токена оператора понимать, что это скобка, понимать - открывающая или нет (isBrace, isOpen).
  В общем случае у нас может быть несколько типов скобок - скобки для группировки операций для повышения их приоритета;
  скобки для функционального каста вида type_name(value); скобки для обозначения вызова функции; скобки для обозначения оператора индексации.
  Например, круглые скобки "()" могут использоваться как для функционального каста, так и для вызова функции, а также для группировки операций;
  фигурные скобки "{}" могут использоваться для функционального каста; фигурные скобки "{}" также могут использоваться для инициализации структуры, 
  в этом случае может быть от нуля до произвольного количества аргументов;
  квадратные скобки могут использоваться для операции индекцсации; угловые скобки могут использоваться для инстанциации шаблонов.
  Скобки также имеют приоритет.
  Идентификатор, после которого следует открывающая скобка вызова функции, является вызовом функции.
  Идентификатор, после которого следует открывающая скобка функционального каста, является функциональнфм кастом.
  Операция индексации может быть как префиксной, так и постфиксной - как [IDX]array, так и array[IDX].

- Оператор. Оператор задаётся токеном оператора. Тип токена - шаблонный (предполагается интегральный). Имя структуры литерала - OperatorToken.

- Отдельно задаётся оператор разделения элементов списка аргументов при вызове функций и при функциональном касте, 
  а также при инициализации структуры. Обычно для этого используется запятая. При разборе вызова функции, при 
  инициализации структуры оператор разделения элементов списка аргументов имеет наивысший приоритет.

- Также может использоваться оператор перечисления. Это многоместный nAry оператор. В качестве такого оператора обычно используется запятая. 
  Оператор разделения элементов списка аргументов и оператор оператор перечисления могут обозначаться одним оператором, поэтому следует
  четко разделять контекст использования данного оператора. С другой стороны, эти операторы могут обозначаться и различными операторами.
  Надо уметь разделять эти случаи использования при совпадении кодов операторов, и при их различии; если операторы обозначаются различно,
  то у нас нет нужды разделять контекст использования.


OperatorAssociativity - перечисление, ассоциативнось оператора, может быть left или right для левосторонних и правосторонних операторов.

OperatorArity - флаговое перечисление, определяет ассоциативность операторов. Флаги: unary - унарная операция; binary - бинарная операция,
может комбинироваться с флагом unary; ternary - тернарная операция; nAry - оператор с произвольным числом аргументов, но не меньше двух, 
при этом для разделения операндов используется один и тот же символ. 

OperatorAffixation - флаговое перечисление, определяет допустимую форму унарного оператора, может быть: флаг prefix - операция может быть префиксной;
флаг postfix - операция может быть postfix. Для всех остальных типов арности: бинарный оператор, тернарный оператор - Operator Affixation не имеет смысла,
они являются инфиксными (располагаются между операндов)

Precedence - интегральный тип, задаёт приоритет (старшинство) операторов, чем меньше число, тем более высокий приоритет у оператора.
Приоритеты операторов в C++ - https://en.cppreference.com/w/cpp/language/operator_precedence.html
Чем меньше число precedence, тем выше приоритет.

BracketKind - перечисление, тип скобки: none - не скобка, open - открывающая скобка, close - закрывающая скобка.

BracketType - флаговое перечисление: none - не скобка, groupping - может использоваться для группировки операций,
functionalCast - функциональный каст (преобразование типа), functionCall - вызов функции, indexation - оператор индексации,
templateInstantiation - задание параметров инстанциации шаблона.


Для токенов OperatorType надо задавать OperatorTraits.

OperatorTraits должен уметь возвращать Associativity, Arity, Affixation и Precedence операторов.

OperatorTraits должны уметь возвращать для тернарных операторов код токена OperatorType, который
отделяет третий аргумент от второго.

Для токенов скобок OperatorTraits должны возвращать парный токен (открывающий или закрывающий), признак BracketKind,
а также признак BracketType.


Функциональный класс парсера выражений получает на вход входные элементы типа ExpressionInputItem по одному,
хранит своё состояние, и строит дерево выражения Expression Tree. с единственным корневым элементом ExpressionNode.

Требуется поддержка унарных, бинарных, тернарных, а также N-арных операторов.

Парсер является шаблонным классом, и в качестве параметра шаблона принимает OperatorTraits.

При ошибках возвращается соответствующее значение ошибки.

До начала обработки ввода вызывается метод initialize - он позволяет переинициализировать ранее использованный парсер.
При окончании входных элементов вызывается метод finalize, он так же может возвращать ошибку.
Метод getExpressionTree() возвращает корневой элемент дерева выражении (Expression Tree).

Выражения не вычисляются непосредственно, а формируют дерево выражений, для того, чтобы можно было производить последующие
повторные вычисления при помощи этого дерева выражений (например, с изменившимися значениями переменных)



DeepSeek рекомендует алгоритм сортировочной станции (shunting yard algorithm)
https://en.wikipedia.org/wiki/Shunting_yard_algorithm
https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D0%BE%D0%B9_%D1%81%D1%82%D0%B0%D0%BD%D1%86%D0%B8%D0%B8
Алгоритм сортировочной станции (рувики) - https://ru.ruwiki.ru/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D0%BE%D0%B9_%D1%81%D1%82%D0%B0%D0%BD%D1%86%D0%B8%D0%B8
The shunting yard algorithm with a train - https://www.youtube.com/watch?v=gHniHE_HvhM

Всё, что вам не рассказали про Shunting Yard - https://habr.com/ru/articles/908062/
Реализации алгоритмов/Алгоритм сортировочной станции - https://ru.wikibooks.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D0%BE%D0%B9_%D1%81%D1%82%D0%B0%D0%BD%D1%86%D0%B8%D0%B8
Почему работает алгоритм преобразования инфиксной записи в постфиксную - https://habr.com/ru/articles/747178/

Парсер формул с помощью метода рекурсивного спуска - https://habr.com/ru/post/122397/
Алгоритм парсинга арифметических выражений         - https://habr.com/ru/post/263775/
Обратная польская запись                           - https://habr.com/ru/post/100869/
Парсер выражений                                   - http://slovesnov.users.sourceforge.net/index.php?parser,russian
Парсер математических выражений                    - https://ru.stackoverflow.com/questions/23842/%D0%9F%D0%B0%D1%80%D1%81%D0%B5%D1%80-%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9
Обратная польская запись                           - https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C

Парсеры Пратта для чайников - https://habr.com/ru/articles/494316/
Prett Parsing — метод Вогана Пратта для разбора выражений - https://habr.com/ru/articles/50349/
Нисходящий парсер с операторным предшествованием - https://habr.com/ru/articles/227241/
Как писать парсеры на JavaScript - https://habr.com/ru/articles/224081/

Crafting Interpreters - https://craftinginterpreters.com/
    Table of Contents - https://craftinginterpreters.com/contents.html
    Compiling Expressions - https://craftinginterpreters.com/compiling-expressions.html

Алгоритм Рутисхаузера - https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A0%D1%83%D1%82%D0%B8%D1%81%D1%85%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B0

Используется язык C++ стандарта не выше 17го.
Код должен компилироваться компиляторами MSVC2019 и GCC 7.3,
и не должен требовать более современных версий данных компиляторов.


Когда требуется проверять оператор на поддержку унарной формы?

- Когда оператор является первым оператором во входном потоке
- Когда оператор является первым оператором после скобки, открывающей список аргументов
- Когда оператор является первым оператором после Parenthes-скобки, группироущей часть выражения
- Когда оператор следует после другого оператора

Операторы могут быть чисто унарными - значит, надо проверять всегда, а то, что выше - 
требуется для unary-binary оператров.
